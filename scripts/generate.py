import shutil
import re
data = open("ts3_functions.in").read()
output = open("autogeneratedFunctions.h","w")
functionMatcher = re.compile(r"\s*(unsigned int|int|void|uint64)\s*\(\*(\w+)+\)\s*\((.*)\);")

types = {
	"const char*" : ["in", "s"],
	"uint64" : ["in", "K"],
	"anyID" : ["in", "i"],
	"size_t" : ["in", "i"],
	"int" : ["in", "i"],
	# output values
	# "char*" : ["out", "s"], 
	"char**" : ["out" , "s"], # return a string
	"int*" : ["out", "i"], # return an int
	"uint64*" : ["out", "K"], # return a large integer
	"anyID**" : ["out", "i"], # return a list of integers
}
functions = []
for line in data.split("\n"):
	match = functionMatcher.match(line)
	if(not match):
		continue
	# print "type:%s,function:%s,params:%s" % (match.group(1), match.group(2), match.group(3))
	type = match.group(1)
	function = match.group(2)
	params = match.group(3).strip().split(",")
	# verify the parameters are all okay
	invalid = False
	letterCodes = []
	identifiers = []
	paramType = []
	direction = []
	for param in params:
		thisParam = []
		split = param.rfind(" ")
		type = param[0:split].strip()
		ident = param[split:].strip()
		thisParam.append("%s %s;" % (type, ident)) # variable declaration
		if type.find("enum") == 0:
			type = "size_t"
		if type not in types.keys():
			invalid = "unknown type %s" % type
			continue
		inout, letter = types[type]
		
		direction.append(inout)
		letterCodes.append(letter) # call parse tuple
		identifiers.append(ident)
		paramType.append(type)
		
	if direction.count("out") > 1:
		invalid = "Too many outs"
		
	if invalid != False:
		print "function %s was rejected because of %s" % (function, invalid)
		continue
	
	# used to build the function struct table later
	functions.append(function)
	
	# BEGIN OUTPUT
	output.write("static PyObject * %s(PyObject *self, PyObject *args)\n" % function)
	output.write("{\n")
	for x in zip(paramType, identifiers, direction):
		if x[2] == "out":
			output.write("\t%s %s;\n" % (x[0][:-1],x[1])) # variable definition
		else:
			output.write("\t%s %s;\n" % (x[0],x[1])) # variable definition
	# parse tuple definition	
	output.write('\tlogDebugFile("Called function %s");\n' % function);
	if direction.count("out") > 0:
		index = direction.index("out")
		_letterCodes = letterCodes[0:index] + letterCodes[index+1:]
		_identifiers = identifiers[0:index] + identifiers[index+1:]
	else:
		_letterCodes = letterCodes
		_identifiers = identifiers
	if len(_identifiers) > 0:	
		output.write("	if (!PyArg_ParseTuple(args")
		output.write(', "%s"' % "".join([x for x in _letterCodes])) # format string
		output.write(', %s' % ", ".join(["&"+x for x in _identifiers])) # variable declaration
		output.write("))\n") 
		output.write("		return NULL;\n")
	if direction.count("out") == 0:
		output.write("	ts3Functions.%s(" % function) # do the function call
		_identifiers = list(identifiers)
		for i in xrange(len(_identifiers)):
			if direction[i] == "out":
				_identifiers[i] = "&" + _identifiers[i]
		output.write(', '.join([x for x in _identifiers]))
		output.write(");\n") # function call
	else:		
		output.write("	if(ts3Functions.%s(" % function) # do the function call
		_identifiers = list(identifiers)
		for i in xrange(len(_identifiers)):
			if direction[i] == "out":
				_identifiers[i] = "&" + _identifiers[i]
		output.write(', '.join([x for x in _identifiers]))
		output.write(") == ERROR_ok) {\n") # function call
		index = direction.index("out")
		# output.write('\t{\n');
		if paramType[index] == "anyID**":
			output.write('\t\tint i;\n')
			output.write('\t\tPyObject* returnValue = PyList_New(0);\n');
			output.write('\t\tfor(i=0; %s[i]!=0; i++){\n' % (identifiers[index]))
			output.write('\t\t\tPyList_Append(returnValue, Py_BuildValue("%s",%s[i]));\n' % (letterCodes[index], identifiers[index]));
			output.write('\t\t}\n')			
		else:
			output.write('\t\tPyObject* returnValue = Py_BuildValue("%s",%s);\n' % (letterCodes[index], identifiers[index]));
			output.write('\t\tif(returnValue == NULL) { return Py_None; }\n');
		if paramType[index].count("*") > 1:
			output.write('\t\tts3Functions.freeMemory(%s);\n' % identifiers[index]);
		output.write('\t\treturn returnValue;\n')
		output.write('\t}\n')
	output.write("\treturn Py_None;\n");
	output.write("}\n")
	# END OUTPUT
output.close()
output = open("structs.h","w")
for x in functions:
	output.write('{"%s",%s,METH_VARARGS,"%s"},\n' % (x,x,x))
output.close()
shutil.copyfile('structs.h', '../src/structs.h')
shutil.copyfile('autogeneratedFunctions.h', '../src/autogeneratedFunctions.h')